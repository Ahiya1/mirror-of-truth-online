<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <link rel="icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="manifest" href="/site.webmanifest" />
    <title>Your Reflection | Mirror of Truth</title>

    <style>
      /* ═══════════════ MIRROR OF TRUTH - COMPLETE REWRITE ═══════════════ */
      /* Revolutionary architecture with flawless functionality */

      /* ╭─ RESET & FOUNDATION ────────────────────────────────────────────╮ */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html {
        scroll-behavior: smooth;
        -webkit-text-size-adjust: 100%;
        -ms-text-size-adjust: 100%;
      }

      body {
        background: #020617;
        color: #fff;
        font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        line-height: 1.6;
        overflow-x: hidden;
        min-height: 100vh;
        position: relative;
        touch-action: manipulation;
      }

      /* ╭─ COSMIC BACKGROUND SYSTEM ──────────────────────────────────────╮ */
      .cosmic-background {
        position: fixed;
        inset: 0;
        z-index: 0;
        pointer-events: none;
      }

      .cosmic-gradient {
        position: absolute;
        inset: 0;
        background: radial-gradient(
            circle at 20% 30%,
            rgba(59, 130, 246, 0.05) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 80% 70%,
            rgba(147, 51, 234, 0.04) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 50% 50%,
            rgba(251, 191, 36, 0.03) 0%,
            transparent 70%
          );
        animation: cosmicShift 80s ease-in-out infinite;
      }

      .starfield {
        position: absolute;
        inset: 0;
        background: radial-gradient(
            circle at 20% 30%,
            rgba(255, 255, 255, 0.3) 0 1px,
            transparent 2px
          ),
          radial-gradient(
            circle at 60% 70%,
            rgba(255, 255, 255, 0.25) 0 1px,
            transparent 2px
          ),
          radial-gradient(
            circle at 80% 20%,
            rgba(255, 255, 255, 0.28) 0 1px,
            transparent 2px
          ),
          radial-gradient(
            circle at 40% 90%,
            rgba(255, 255, 255, 0.22) 0 1px,
            transparent 2px
          );
        background-size: 1200px 900px, 1600px 1100px, 900px 1300px,
          1400px 1000px;
        opacity: 0.08;
        animation: starfieldDrift 180s linear infinite;
      }

      @keyframes cosmicShift {
        0%,
        100% {
          transform: scale(1) rotate(0deg);
        }
        33% {
          transform: scale(1.05) rotate(120deg);
        }
        66% {
          transform: scale(0.98) rotate(240deg);
        }
      }

      @keyframes starfieldDrift {
        0% {
          transform: translate(0, 0);
        }
        100% {
          transform: translate(-60px, -60px);
        }
      }

      /* ╭─ TONE-SPECIFIC BACKGROUNDS ─────────────────────────────────────╮ */
      .tone-elements {
        position: fixed;
        inset: 0;
        z-index: 1;
        pointer-events: none;
      }

      /* Fusion Breathing Elements */
      .fusion-breath {
        position: absolute;
        border-radius: 50%;
        background: radial-gradient(
          circle,
          rgba(251, 191, 36, 0.3) 0%,
          rgba(245, 158, 11, 0.15) 30%,
          rgba(217, 119, 6, 0.08) 60%,
          transparent 80%
        );
        filter: blur(35px);
        animation: fusionBreathe 25s ease-in-out infinite;
      }

      @keyframes fusionBreathe {
        0%,
        100% {
          opacity: 0;
          transform: scale(0.4) translate(0, 0);
        }
        25% {
          opacity: 0.6;
          transform: scale(1.1) translate(30px, -40px);
        }
        50% {
          opacity: 0.8;
          transform: scale(1.4) translate(-15px, 25px);
        }
        75% {
          opacity: 0.5;
          transform: scale(0.9) translate(40px, 15px);
        }
      }

      /* Gentle Stars */
      .gentle-star {
        position: absolute;
        width: 3px;
        height: 3px;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 50%;
        box-shadow: 0 0 8px rgba(255, 255, 255, 0.7),
          0 0 15px rgba(255, 255, 255, 0.4);
        animation: gentleTwinkle 10s ease-in-out infinite;
      }

      @keyframes gentleTwinkle {
        0%,
        100% {
          opacity: 0;
          transform: scale(0.4);
        }
        50% {
          opacity: 1;
          transform: scale(1.3);
        }
      }

      /* Intense Swirls */
      .intense-swirl {
        position: absolute;
        width: clamp(180px, 35vw, 240px);
        height: clamp(180px, 35vw, 240px);
        background: radial-gradient(
          circle at 30% 30%,
          rgba(147, 51, 234, 0.35) 0%,
          rgba(168, 85, 247, 0.18) 30%,
          rgba(139, 92, 246, 0.1) 60%,
          transparent 80%
        );
        filter: blur(30px);
        border-radius: 50%;
        animation: intenseSwirl 18s ease-in-out infinite;
      }

      @keyframes intenseSwirl {
        0%,
        100% {
          opacity: 0;
          transform: rotate(0deg) scale(0.2);
        }
        25% {
          opacity: 0.7;
          transform: rotate(180deg) scale(1.1);
        }
        50% {
          opacity: 0.9;
          transform: rotate(360deg) scale(1.4);
        }
        75% {
          opacity: 0.6;
          transform: rotate(540deg) scale(0.8);
        }
      }

      /* ╭─ MAIN LAYOUT STRUCTURE ─────────────────────────────────────────╮ */
      .main-container {
        position: relative;
        z-index: 10;
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: clamp(1rem, 3vw, 2rem);
      }

      .content-wrapper {
        width: 100%;
        max-width: 900px;
        margin: 0 auto;
      }

      /* ╭─ SECTION MANAGEMENT ────────────────────────────────────────────╮ */
      .mirror-section {
        width: 100%;
        text-align: center;
        transition: opacity 0.6s ease, transform 0.6s ease;
      }

      .mirror-section.is-hidden {
        display: none;
      }

      .mirror-section.is-visible {
        display: block;
        opacity: 1;
        transform: translateY(0);
      }

      /* ╭─ TONE SELECTOR ──────────────────────────────────────────────────╮ */
      .tone-selector {
        margin-bottom: clamp(3rem, 5vw, 4rem);
      }

      .tone-label {
        font-size: clamp(1.1rem, 3vw, 1.3rem);
        color: rgba(255, 255, 255, 0.9);
        margin-bottom: clamp(1.5rem, 3vw, 2rem);
        font-weight: 300;
        letter-spacing: 0.8px;
        position: relative;
      }

      .tone-label::after {
        content: "";
        position: absolute;
        bottom: -8px;
        left: 50%;
        transform: translateX(-50%);
        width: 60px;
        height: 1px;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 255, 255, 0.3),
          transparent
        );
      }

      .tone-buttons {
        display: flex;
        gap: clamp(1rem, 2.5vw, 1.5rem);
        justify-content: center;
        flex-wrap: wrap;
      }

      .tone-button {
        flex: 1;
        min-width: 140px;
        max-width: 220px;
        padding: clamp(1rem, 2.5vw, 1.4rem) clamp(1.2rem, 3vw, 1.6rem);
        background: rgba(255, 255, 255, 0.06);
        backdrop-filter: blur(25px) saturate(120%);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 18px;
        color: rgba(255, 255, 255, 0.75);
        font-size: clamp(0.9rem, 2.2vw, 1rem);
        font-weight: 400;
        letter-spacing: 0.4px;
        cursor: pointer;
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        overflow: hidden;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
        user-select: none;
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 52px;
      }

      .tone-button::before {
        content: "";
        position: absolute;
        inset: 0;
        background: linear-gradient(
          45deg,
          transparent,
          rgba(255, 255, 255, 0.1),
          transparent
        );
        transform: translateX(-100%);
        transition: transform 0.6s ease;
      }

      .tone-button:hover::before {
        transform: translateX(100%);
      }

      .tone-button:hover {
        background: rgba(255, 255, 255, 0.1);
        border-color: rgba(255, 255, 255, 0.2);
        color: rgba(255, 255, 255, 0.95);
        transform: translateY(-3px) scale(1.02);
        box-shadow: 0 10px 30px rgba(255, 255, 255, 0.1);
      }

      .tone-button:active {
        transform: translateY(-1px) scale(0.98);
      }

      .tone-button.is-selected {
        background: rgba(255, 255, 255, 0.12);
        border-color: rgba(255, 255, 255, 0.25);
        color: #fff;
        box-shadow: 0 8px 25px rgba(255, 255, 255, 0.15);
      }

      /* Tone-specific selection styles */
      .tone-button[data-tone="fusion"].is-selected {
        border-color: rgba(251, 191, 36, 0.4);
        background: rgba(251, 191, 36, 0.08);
        box-shadow: 0 8px 25px rgba(251, 191, 36, 0.2);
      }

      .tone-button[data-tone="gentle"].is-selected {
        border-color: rgba(255, 255, 255, 0.3);
        background: rgba(255, 255, 255, 0.1);
        box-shadow: 0 8px 25px rgba(255, 255, 255, 0.2);
      }

      .tone-button[data-tone="intense"].is-selected {
        border-color: rgba(147, 51, 234, 0.4);
        background: rgba(147, 51, 234, 0.08);
        box-shadow: 0 8px 25px rgba(147, 51, 234, 0.2);
      }

      /* ╭─ QUESTIONS FORM ─────────────────────────────────────────────────╮ */
      .questions-form {
        text-align: left;
      }

      .question-card {
        margin-bottom: clamp(2.5rem, 4vw, 3.5rem);
        padding: clamp(2rem, 4vw, 2.5rem) clamp(1.5rem, 3vw, 2rem);
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.04) 0%,
          rgba(255, 255, 255, 0.015) 100%
        );
        backdrop-filter: blur(45px) saturate(130%);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 24px;
        position: relative;
        overflow: hidden;
        transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .question-card::before {
        content: "";
        position: absolute;
        inset: 0;
        background: radial-gradient(
          circle at 25% 50%,
          rgba(255, 255, 255, 0.03) 0%,
          transparent 60%
        );
        opacity: 0;
        transition: opacity 0.6s ease;
      }

      .question-card:hover::before {
        opacity: 1;
      }

      .question-card:hover {
        border-color: rgba(255, 255, 255, 0.15);
        transform: translateY(-4px);
        box-shadow: 0 15px 50px rgba(255, 255, 255, 0.08);
      }

      .question-number {
        font-size: clamp(0.7rem, 2vw, 0.8rem);
        opacity: 0.45;
        margin-bottom: clamp(1rem, 2vw, 1.2rem);
        text-transform: uppercase;
        letter-spacing: 2.5px;
        color: rgba(255, 255, 255, 0.45);
        font-weight: 600;
        position: relative;
      }

      .question-number::after {
        content: "";
        position: absolute;
        left: 0;
        bottom: -4px;
        width: 30px;
        height: 1px;
        background: linear-gradient(
          90deg,
          rgba(255, 255, 255, 0.3),
          transparent
        );
      }

      .question-title {
        font-size: clamp(1.3rem, 4vw, 1.6rem);
        margin-bottom: clamp(0.8rem, 1.5vw, 1rem);
        line-height: 1.3;
        color: rgba(255, 255, 255, 0.97);
        font-weight: 300;
        letter-spacing: 0.3px;
        text-shadow: 0 2px 15px rgba(255, 255, 255, 0.05);
      }

      .question-subtitle {
        font-size: clamp(0.9rem, 2.2vw, 1rem);
        opacity: 0.6;
        margin-bottom: clamp(1.5rem, 3vw, 2rem);
        font-style: italic;
        color: rgba(255, 255, 255, 0.6);
        line-height: 1.4;
        font-weight: 300;
        letter-spacing: 0.2px;
      }

      /* ╭─ FORM INPUTS ────────────────────────────────────────────────────╮ */
      .input-group {
        position: relative;
      }

      .form-textarea {
        width: 100%;
        padding: clamp(1.4rem, 3vw, 1.6rem);
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.05) 0%,
          rgba(255, 255, 255, 0.025) 100%
        );
        backdrop-filter: blur(25px) saturate(120%);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 18px;
        color: #fff;
        font-size: clamp(1rem, 2.2vw, 1.1rem);
        font-family: inherit;
        line-height: 1.6;
        resize: vertical;
        min-height: clamp(140px, 25vw, 180px);
        transition: all 0.4s ease;
        -webkit-appearance: none;
        appearance: none;
        box-sizing: border-box;
      }

      .form-textarea:focus {
        outline: none;
        border-color: rgba(255, 255, 255, 0.3);
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.08) 0%,
          rgba(255, 255, 255, 0.04) 100%
        );
        box-shadow: 0 0 40px rgba(255, 255, 255, 0.08),
          inset 0 1px 0 rgba(255, 255, 255, 0.12);
        transform: translateY(-2px);
      }

      .form-textarea::placeholder {
        color: rgba(255, 255, 255, 0.4);
        font-style: italic;
        font-weight: 300;
      }

      /* Character Counter */
      .char-counter {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 0.8rem;
        padding: 0 0.2rem;
      }

      .char-count {
        font-size: clamp(0.75rem, 1.8vw, 0.85rem);
        color: rgba(255, 255, 255, 0.5);
        font-weight: 400;
        transition: all 0.3s ease;
      }

      .char-count.approaching-limit {
        color: rgba(251, 191, 36, 0.8);
        font-weight: 500;
      }

      .char-count.at-limit {
        color: rgba(239, 68, 68, 0.9);
        font-weight: 600;
        animation: charPulse 2s ease-in-out infinite;
      }

      @keyframes charPulse {
        0%,
        100% {
          opacity: 0.9;
        }
        50% {
          opacity: 1;
        }
      }

      .char-progress {
        width: 60px;
        height: 3px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 2px;
        overflow: hidden;
        position: relative;
      }

      .char-progress-bar {
        height: 100%;
        background: linear-gradient(
          90deg,
          rgba(16, 185, 129, 0.8) 0%,
          rgba(251, 191, 36, 0.8) 70%,
          rgba(239, 68, 68, 0.9) 100%
        );
        border-radius: 2px;
        transition: width 0.3s ease;
        width: 0%;
      }

      /* ╭─ YES/NO BUTTONS ─────────────────────────────────────────────────╮ */
      .choice-buttons {
        display: flex;
        gap: clamp(1rem, 2.5vw, 1.4rem);
        margin-top: clamp(1rem, 2vw, 1.2rem);
      }

      .choice-button {
        flex: 1;
        padding: clamp(1rem, 2.5vw, 1.2rem);
        background: rgba(255, 255, 255, 0.05);
        backdrop-filter: blur(25px);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 16px;
        color: rgba(255, 255, 255, 0.75);
        font-size: clamp(1rem, 2.2vw, 1.1rem);
        font-weight: 500;
        letter-spacing: 0.5px;
        cursor: pointer;
        transition: all 0.4s ease;
        position: relative;
        overflow: hidden;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
        user-select: none;
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 52px;
      }

      .choice-button::before {
        content: "";
        position: absolute;
        inset: 0;
        background: linear-gradient(
          45deg,
          transparent,
          rgba(255, 255, 255, 0.1),
          transparent
        );
        transform: translateX(-100%);
        transition: transform 0.6s ease;
      }

      .choice-button:hover::before {
        transform: translateX(100%);
      }

      .choice-button:hover {
        background: rgba(255, 255, 255, 0.08);
        border-color: rgba(255, 255, 255, 0.2);
        color: rgba(255, 255, 255, 0.95);
        transform: translateY(-2px) scale(1.02);
      }

      .choice-button:active {
        transform: translateY(0) scale(0.98);
      }

      .choice-button.is-selected {
        background: rgba(255, 255, 255, 0.15);
        border-color: rgba(255, 255, 255, 0.3);
        color: #fff;
        box-shadow: 0 0 20px rgba(255, 255, 255, 0.12);
        transform: scale(1.05);
      }

      /* ╭─ DATE INPUT ──────────────────────────────────────────────────────╮ */
      .date-container {
        opacity: 0;
        visibility: hidden;
        height: 0;
        overflow: hidden;
        display: flex;
        align-items: center;
        gap: clamp(1rem, 2.5vw, 1.5rem);
        margin-top: clamp(1.5rem, 3vw, 2rem);
        padding: 0 clamp(1rem, 2.5vw, 1.4rem);
        background: rgba(255, 255, 255, 0.03);
        border-radius: 16px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        transition: all 0.4s ease;
        flex-wrap: wrap;
        position: relative;
        z-index: 10;
      }

      .date-container.is-visible {
        opacity: 1;
        visibility: visible;
        height: auto;
        padding: clamp(1rem, 2.5vw, 1.4rem);
        animation: dateSlideIn 0.6s ease;
      }

      @keyframes dateSlideIn {
        from {
          opacity: 0;
          transform: translateY(15px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .date-label {
        color: rgba(255, 255, 255, 0.85);
        font-weight: 500;
        font-size: clamp(0.9rem, 2.2vw, 1rem);
        min-width: fit-content;
        pointer-events: none;
        user-select: none;
      }

      .date-input {
        flex: 1;
        min-width: 180px;
        padding: clamp(0.8rem, 2vw, 1rem);
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 12px;
        color: #fff;
        font-family: inherit;
        font-size: clamp(0.9rem, 2vw, 1rem);
        transition: all 0.3s ease;
        position: relative;
        z-index: 20;
        pointer-events: auto;
        cursor: pointer;
      }

      .date-input:focus {
        outline: none;
        border-color: rgba(255, 255, 255, 0.3);
        background: rgba(255, 255, 255, 0.08);
        box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
      }

      .date-input:hover {
        border-color: rgba(255, 255, 255, 0.25);
        background: rgba(255, 255, 255, 0.07);
      }

      /* ╭─ SUBMIT BUTTON ──────────────────────────────────────────────────╮ */
      .submit-button {
        width: 100%;
        margin-top: clamp(3rem, 5vw, 4rem);
        padding: clamp(1.4rem, 3vw, 1.8rem) clamp(2rem, 4vw, 2.5rem);
        font-size: clamp(1.1rem, 2.8vw, 1.3rem);
        font-weight: 500;
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.1) 0%,
          rgba(255, 255, 255, 0.06) 100%
        );
        backdrop-filter: blur(30px) saturate(120%);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 24px;
        color: #fff;
        cursor: pointer;
        transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        letter-spacing: 1px;
        text-transform: uppercase;
        position: relative;
        overflow: hidden;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
        user-select: none;
        min-height: 64px;
      }

      .submit-button::before {
        content: "";
        position: absolute;
        inset: 0;
        background: linear-gradient(
          45deg,
          transparent,
          rgba(255, 255, 255, 0.15),
          transparent
        );
        transform: translateX(-100%);
        transition: transform 0.8s ease;
      }

      .submit-button:hover::before {
        transform: translateX(100%);
      }

      .submit-button:hover:not(:disabled) {
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.15) 0%,
          rgba(255, 255, 255, 0.08) 100%
        );
        border-color: rgba(255, 255, 255, 0.35);
        transform: translateY(-4px) scale(1.02);
        box-shadow: 0 20px 60px rgba(255, 255, 255, 0.15);
        letter-spacing: 1.5px;
      }

      .submit-button:active:not(:disabled) {
        transform: translateY(-2px) scale(0.98);
      }

      .submit-button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none;
      }

      /* ╭─ LOADING SECTION ────────────────────────────────────────────────╮ */
      .loading-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: clamp(2rem, 4vw, 3rem);
        padding: clamp(3rem, 6vw, 4rem);
      }

      .loading-circle {
        width: clamp(140px, 30vw, 180px);
        height: clamp(140px, 30vw, 180px);
        border-radius: 50%;
        background: radial-gradient(
          circle,
          rgba(255, 255, 255, 0.15) 0%,
          rgba(255, 255, 255, 0.05) 40%,
          rgba(255, 255, 255, 0.02) 70%,
          transparent 85%
        );
        animation: breatheLoading 4.5s ease-in-out infinite;
        position: relative;
        box-shadow: 0 0 60px rgba(255, 255, 255, 0.1),
          inset 0 0 30px rgba(255, 255, 255, 0.05);
      }

      .loading-circle::after {
        content: "";
        position: absolute;
        inset: 25px;
        border-radius: 50%;
        background: radial-gradient(
          circle,
          rgba(255, 255, 255, 0.1) 0%,
          rgba(255, 255, 255, 0.03) 50%,
          transparent 75%
        );
        animation: breatheInner 4.5s ease-in-out infinite;
      }

      @keyframes breatheLoading {
        0%,
        100% {
          transform: scale(1);
          opacity: 0.7;
        }
        50% {
          transform: scale(1.15);
          opacity: 1;
        }
      }

      @keyframes breatheInner {
        0%,
        100% {
          transform: scale(1) rotate(0deg);
          opacity: 0.5;
        }
        50% {
          transform: scale(1.3) rotate(180deg);
          opacity: 0.9;
        }
      }

      .loading-text {
        font-size: clamp(1.1rem, 3vw, 1.4rem);
        font-weight: 300;
        opacity: 0.8;
        text-align: center;
        letter-spacing: 1px;
        color: rgba(255, 255, 255, 0.85);
        animation: loadingPulse 3s ease-in-out infinite;
      }

      @keyframes loadingPulse {
        0%,
        100% {
          opacity: 0.6;
        }
        50% {
          opacity: 1;
        }
      }

      /* ╭─ RESULTS SECTION ────────────────────────────────────────────────╮ */
      .results-container {
        text-align: left;
        max-width: 800px;
        margin: 0 auto;
        padding: 0 clamp(1rem, 2vw, 2rem);
      }

      .admin-notice {
        background: rgba(168, 85, 247, 0.1);
        border: 1px solid rgba(168, 85, 247, 0.25);
        color: #d8b4fe;
        padding: clamp(1rem, 2vw, 1.4rem) clamp(1.5rem, 3vw, 2rem);
        border-radius: 16px;
        margin-bottom: clamp(2rem, 3vw, 2.5rem);
        font-size: clamp(0.85rem, 2vw, 0.95rem);
        font-weight: 400;
        letter-spacing: 0.3px;
        text-align: center;
        animation: adminGlow 4s ease-in-out infinite;
        position: relative;
        overflow: hidden;
      }

      .admin-notice::before {
        content: "";
        position: absolute;
        inset: 0;
        background: linear-gradient(
          45deg,
          transparent,
          rgba(168, 85, 247, 0.1),
          transparent
        );
        transform: translateX(-100%);
        animation: adminShimmer 3s ease-in-out infinite;
      }

      @keyframes adminGlow {
        0%,
        100% {
          background: rgba(168, 85, 247, 0.1);
          border-color: rgba(168, 85, 247, 0.25);
        }
        50% {
          background: rgba(168, 85, 247, 0.15);
          border-color: rgba(168, 85, 247, 0.35);
        }
      }

      @keyframes adminShimmer {
        0% {
          transform: translateX(-100%);
        }
        100% {
          transform: translateX(100%);
        }
      }

      .results-backdrop {
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.04) 0%,
          rgba(255, 255, 255, 0.015) 100%
        );
        backdrop-filter: blur(50px) saturate(130%);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 28px;
        padding: clamp(2rem, 4vw, 3rem) clamp(1.5rem, 3vw, 2.5rem);
        margin-bottom: clamp(2rem, 4vw, 3rem);
        box-shadow: 0 25px 80px rgba(0, 0, 0, 0.4),
          inset 0 1px 0 rgba(255, 255, 255, 0.08);
        position: relative;
        overflow: hidden;
        animation: resultsGlow 1s ease-out;
      }

      @keyframes resultsGlow {
        from {
          opacity: 0;
          transform: translateY(30px) scale(0.95);
        }
        to {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
      }

      .results-content {
        background: rgba(255, 255, 255, 0.97);
        color: #1a1a2e;
        padding: clamp(2.5rem, 5vw, 3.5rem) clamp(2rem, 4vw, 3rem);
        border-radius: 24px;
        box-shadow: 0 15px 60px rgba(0, 0, 0, 0.25);
        font-size: clamp(1.05rem, 2.5vw, 1.2rem);
        line-height: 1.7;
        font-weight: 300;
        position: relative;
      }

      .results-content p {
        margin: 0 0 1.8rem 0;
      }

      .results-content p:last-child {
        margin-bottom: 0;
      }

      .results-content strong {
        font-weight: 600;
        color: #16213e;
        background: linear-gradient(135deg, #667eea, #764ba2);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        position: relative;
      }

      .results-content strong::after {
        content: "";
        position: absolute;
        bottom: -2px;
        left: 0;
        right: 0;
        height: 1px;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(102, 126, 234, 0.3),
          transparent
        );
      }

      .results-content em {
        font-style: italic;
        color: #4a5568;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
      }

      /* ╭─ ACTION BUTTONS ─────────────────────────────────────────────────╮ */
      .results-actions {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: clamp(1rem, 2.5vw, 1.5rem);
        margin-top: clamp(2rem, 4vw, 3rem);
      }

      .action-button {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: clamp(0.6rem, 1.5vw, 0.8rem);
        padding: clamp(1rem, 2.5vw, 1.4rem) clamp(1.2rem, 3vw, 1.6rem);
        background: rgba(255, 255, 255, 0.06);
        backdrop-filter: blur(25px);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 18px;
        color: rgba(255, 255, 255, 0.9);
        font-weight: 500;
        letter-spacing: 0.4px;
        text-decoration: none;
        font-size: clamp(0.9rem, 2.2vw, 1rem);
        cursor: pointer;
        transition: all 0.4s ease;
        position: relative;
        overflow: hidden;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
        user-select: none;
        min-height: 56px;
        min-width: 140px;
      }

      .action-button::before {
        content: "";
        position: absolute;
        inset: 0;
        background: linear-gradient(
          45deg,
          transparent,
          rgba(255, 255, 255, 0.1),
          transparent
        );
        transform: translateX(-100%);
        transition: transform 0.6s ease;
      }

      .action-button:hover::before {
        transform: translateX(100%);
      }

      .action-button:hover {
        background: rgba(255, 255, 255, 0.12);
        border-color: rgba(255, 255, 255, 0.3);
        transform: translateY(-3px) scale(1.05);
        box-shadow: 0 15px 40px rgba(255, 255, 255, 0.15);
      }

      .action-button:active {
        transform: translateY(-1px) scale(0.98);
      }

      /* Special button styles */
      .artifact-button {
        background: linear-gradient(
          135deg,
          rgba(251, 191, 36, 0.15) 0%,
          rgba(245, 158, 11, 0.1) 100%
        ) !important;
        border-color: rgba(251, 191, 36, 0.3) !important;
        color: rgba(251, 191, 36, 0.95) !important;
      }

      .artifact-button:hover {
        background: linear-gradient(
          135deg,
          rgba(251, 191, 36, 0.25) 0%,
          rgba(245, 158, 11, 0.15) 100%
        ) !important;
        border-color: rgba(251, 191, 36, 0.5) !important;
        box-shadow: 0 15px 40px rgba(251, 191, 36, 0.25) !important;
      }

      .fresh-button {
        background: linear-gradient(
          135deg,
          rgba(16, 185, 129, 0.15) 0%,
          rgba(5, 150, 105, 0.1) 100%
        ) !important;
        border-color: rgba(16, 185, 129, 0.3) !important;
        color: rgba(16, 185, 129, 0.95) !important;
      }

      .fresh-button:hover {
        background: linear-gradient(
          135deg,
          rgba(16, 185, 129, 0.25) 0%,
          rgba(5, 150, 105, 0.15) 100%
        ) !important;
        border-color: rgba(16, 185, 129, 0.5) !important;
        box-shadow: 0 15px 40px rgba(16, 185, 129, 0.25) !important;
      }

      .creator-button {
        background: linear-gradient(
          135deg,
          rgba(147, 51, 234, 0.15),
          rgba(59, 130, 246, 0.1)
        ) !important;
        border-color: rgba(147, 51, 234, 0.3) !important;
      }

      .creator-button:hover {
        border-color: rgba(147, 51, 234, 0.5) !important;
        box-shadow: 0 8px 25px rgba(147, 51, 234, 0.2) !important;
      }

      /* Premium badge */
      .premium-badge {
        position: absolute;
        top: -1px;
        right: 1.5rem;
        background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
        color: white;
        padding: 0.4rem 1rem;
        border-radius: 0 0 16px 16px;
        font-size: 0.8rem;
        font-weight: 600;
        letter-spacing: 0.5px;
        text-transform: uppercase;
        box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3);
        z-index: 20;
      }

      /* ╭─ LIMIT EXCEEDED SCREEN ──────────────────────────────────────────╮ */
      .limit-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 60vh;
        padding: clamp(2rem, 5vw, 4rem);
        text-align: center;
      }

      .limit-content {
        max-width: 600px;
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.05) 0%,
          rgba(255, 255, 255, 0.02) 100%
        );
        backdrop-filter: blur(25px) saturate(120%);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 28px;
        padding: clamp(2.5rem, 5vw, 3.5rem);
        position: relative;
        overflow: hidden;
      }

      .limit-icon {
        font-size: clamp(3rem, 6vw, 4rem);
        margin-bottom: 1.5rem;
        opacity: 0.8;
      }

      .limit-title {
        font-size: clamp(1.5rem, 4vw, 2rem);
        font-weight: 300;
        color: rgba(255, 255, 255, 0.95);
        margin-bottom: 1rem;
        letter-spacing: 0.5px;
      }

      .limit-message {
        font-size: clamp(1rem, 2.5vw, 1.2rem);
        color: rgba(255, 255, 255, 0.8);
        line-height: 1.6;
        margin-bottom: 2rem;
      }

      .limit-stats {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1.5rem;
        margin-bottom: 2.5rem;
        padding: 1.5rem;
        background: rgba(255, 255, 255, 0.03);
        border-radius: 16px;
        border: 1px solid rgba(255, 255, 255, 0.08);
      }

      .stat-item {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      .stat-label {
        font-size: 0.9rem;
        color: rgba(255, 255, 255, 0.6);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        font-weight: 500;
      }

      .stat-value {
        font-size: 1.2rem;
        color: rgba(255, 255, 255, 0.95);
        font-weight: 600;
      }

      .limit-actions {
        display: flex;
        gap: 1rem;
        margin-bottom: 2rem;
        flex-wrap: wrap;
        justify-content: center;
      }

      .upgrade-button {
        display: flex;
        align-items: center;
        gap: 0.8rem;
        padding: 1.2rem 2rem;
        background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        border: none;
        border-radius: 16px;
        color: white;
        font-size: 1.1rem;
        font-weight: 600;
        text-decoration: none;
        cursor: pointer;
        transition: all 0.3s ease;
        min-width: 200px;
        justify-content: center;
      }

      .upgrade-button:hover {
        background: linear-gradient(135deg, #059669 0%, #047857 100%);
        transform: translateY(-2px);
        box-shadow: 0 10px 30px rgba(16, 185, 129, 0.3);
      }

      .back-button {
        display: flex;
        align-items: center;
        gap: 0.8rem;
        padding: 1.2rem 2rem;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 16px;
        color: rgba(255, 255, 255, 0.9);
        font-size: 1rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.3s ease;
        min-width: 180px;
        justify-content: center;
      }

      .back-button:hover {
        background: rgba(255, 255, 255, 0.1);
        border-color: rgba(255, 255, 255, 0.25);
        transform: translateY(-2px);
      }

      .limit-help {
        padding: 1.5rem;
        background: rgba(255, 255, 255, 0.02);
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      .limit-help p {
        font-size: 0.9rem;
        color: rgba(255, 255, 255, 0.6);
        line-height: 1.5;
        margin: 0;
      }

      /* ╭─ FEEDBACK SECTION ───────────────────────────────────────────────╮ */
      .feedback-section {
        margin: 3rem 0;
        padding: 2.5rem;
        background: rgba(255, 255, 255, 0.05);
        backdrop-filter: blur(20px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 24px;
        transition: all 0.8s ease;
      }

      .feedback-content {
        text-align: center;
        max-width: 600px;
        margin: 0 auto;
      }

      .feedback-title {
        font-size: clamp(1.2rem, 3vw, 1.4rem);
        font-weight: 300;
        color: rgba(255, 255, 255, 0.95);
        margin-bottom: 2rem;
        line-height: 1.4;
      }

      .rating-container {
        display: flex;
        justify-content: center;
        gap: 0.8rem;
        margin-bottom: 0.5rem;
        flex-wrap: wrap;
      }

      .rating-button {
        width: 48px;
        height: 48px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(255, 255, 255, 0.05);
        border-radius: 12px;
        color: rgba(255, 255, 255, 0.8);
        font-size: 1.1rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
        user-select: none;
      }

      .rating-button:hover {
        background: rgba(255, 255, 255, 0.1);
        border-color: rgba(255, 255, 255, 0.4);
        transform: translateY(-2px);
      }

      .rating-button.is-selected {
        background: linear-gradient(135deg, #10b981, #059669);
        border-color: #10b981;
        color: white;
        font-weight: 600;
        transform: scale(1.1);
      }

      .rating-labels {
        display: flex;
        justify-content: space-between;
        max-width: 500px;
        margin: 0 auto 2rem;
        font-size: 0.9rem;
        opacity: 0.6;
      }

      .feedback-textarea {
        width: 100%;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        color: rgba(255, 255, 255, 0.9);
        border-radius: 16px;
        padding: 1rem;
        margin-bottom: 2rem;
        resize: vertical;
        min-height: 80px;
        font-family: inherit;
        font-size: 1rem;
        line-height: 1.6;
        transition: all 0.3s ease;
      }

      .feedback-textarea:focus {
        outline: none;
        border-color: rgba(255, 255, 255, 0.3);
        background: rgba(255, 255, 255, 0.08);
      }

      .feedback-textarea::placeholder {
        color: rgba(255, 255, 255, 0.4);
      }

      .feedback-buttons {
        display: flex;
        gap: 1rem;
        justify-content: center;
      }

      .feedback-submit,
      .feedback-skip {
        padding: 1rem 2rem;
        border-radius: 16px;
        border: none;
        font-size: 1rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.3s ease;
        font-family: inherit;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
        user-select: none;
      }

      .feedback-submit {
        background: linear-gradient(135deg, #10b981, #059669);
        color: white;
      }

      .feedback-submit:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(16, 185, 129, 0.3);
      }

      .feedback-submit:disabled {
        opacity: 0.7;
        cursor: not-allowed;
        transform: none;
      }

      .feedback-skip {
        background: transparent;
        color: rgba(255, 255, 255, 0.6);
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .feedback-skip:hover {
        background: rgba(255, 255, 255, 0.05);
        color: rgba(255, 255, 255, 0.8);
        border-color: rgba(255, 255, 255, 0.3);
      }

      /* ╭─ RESPONSIVE DESIGN ──────────────────────────────────────────────╮ */
      @media (max-width: 768px) {
        .main-container {
          padding: clamp(0.5rem, 2vw, 1rem);
        }

        .tone-buttons {
          flex-direction: column;
          gap: clamp(1rem, 2vw, 1.2rem);
        }

        .tone-button {
          min-width: auto;
          max-width: none;
        }

        .choice-buttons {
          flex-direction: column;
          gap: clamp(1rem, 2vw, 1.2rem);
        }

        .date-container {
          flex-direction: column;
          align-items: stretch;
          gap: clamp(1rem, 2vw, 1.2rem);
        }

        .results-actions {
          grid-template-columns: 1fr;
          gap: clamp(1rem, 2vw, 1.2rem);
        }

        .feedback-buttons {
          flex-direction: column;
          gap: 1rem;
        }

        .feedback-submit,
        .feedback-skip {
          width: 100%;
        }

        .limit-stats {
          grid-template-columns: 1fr;
          gap: 1rem;
        }

        .limit-actions {
          flex-direction: column;
          align-items: center;
        }

        .upgrade-button,
        .back-button {
          width: 100%;
          max-width: 280px;
        }
      }

      @media (max-width: 480px) {
        .question-card {
          padding: clamp(1.2rem, 2.5vw, 1.6rem) clamp(0.8rem, 2vw, 1.2rem);
          margin-bottom: clamp(1.5rem, 2.5vw, 2rem);
          border-radius: 18px;
        }

        .form-textarea {
          padding: clamp(1.2rem, 2.5vw, 1.4rem);
          min-height: clamp(120px, 22vw, 150px);
        }

        .results-backdrop {
          padding: clamp(1.2rem, 2.5vw, 1.6rem) clamp(0.8rem, 2vw, 1.2rem);
          border-radius: 22px;
        }

        .results-content {
          padding: clamp(1.2rem, 2.5vw, 1.6rem) clamp(0.8rem, 2vw, 1.2rem);
          border-radius: 18px;
        }
      }

      /* ╭─ ACCESSIBILITY ──────────────────────────────────────────────────╮ */
      @media (prefers-reduced-motion: reduce) {
        *,
        *::before,
        *::after {
          animation-duration: 0.01ms !important;
          animation-iteration-count: 1 !important;
          transition-duration: 0.01ms !important;
        }
      }

      .tone-button:focus-visible,
      .choice-button:focus-visible,
      .form-textarea:focus-visible,
      .submit-button:focus-visible,
      .action-button:focus-visible {
        outline: 2px solid rgba(255, 255, 255, 0.6);
        outline-offset: 2px;
      }

      /* Ensure date input is always clickable */
      .date-container.is-visible .date-input {
        pointer-events: auto !important;
        cursor: pointer !important;
        position: relative !important;
        z-index: 100 !important;
      }

      .date-container.is-visible
        .date-input::-webkit-calendar-picker-indicator {
        cursor: pointer;
        opacity: 0.8;
        filter: invert(1);
      }

      /* ╭─ UTILITY CLASSES ────────────────────────────────────────────────╮ */
      .is-hidden {
        display: none !important;
      }
      .is-visible {
        display: block !important;
      }

      /* Custom animations for focus effects */
      @keyframes subtleExpand {
        0% {
          opacity: 0;
          transform: scale(0.4);
        }
        50% {
          opacity: 0.4;
        }
        100% {
          opacity: 0;
          transform: scale(2.5);
        }
      }

      @keyframes subtleTwinkle {
        0% {
          opacity: 0;
          transform: scale(0) rotate(0deg);
        }
        50% {
          opacity: 1;
          transform: scale(1.2) rotate(180deg);
        }
        100% {
          opacity: 0;
          transform: scale(0) rotate(360deg);
        }
      }

      @keyframes subtleSwirl {
        0% {
          opacity: 0;
          transform: scale(0.5) rotate(0deg);
        }
        50% {
          opacity: 0.5;
          transform: scale(1.2) rotate(180deg);
        }
        100% {
          opacity: 0;
          transform: scale(1.8) rotate(360deg);
        }
      }
    </style>
  </head>

  <body>
    <!-- Cosmic Background -->
    <div class="cosmic-background">
      <div class="cosmic-gradient"></div>
      <div class="starfield"></div>
    </div>

    <!-- Tone-specific Background Elements -->
    <div class="tone-elements" id="toneElements"></div>

    <!-- Main Container -->
    <div class="main-container">
      <div class="content-wrapper">
        <!-- Questions Section -->
        <section class="mirror-section is-visible" id="questionsSection">
          <!-- Tone Selector -->
          <div class="tone-selector">
            <div class="tone-label">Choose the voice of your reflection</div>
            <div class="tone-buttons">
              <button
                class="tone-button is-selected"
                data-tone="fusion"
                type="button"
              >
                Let the Mirror Breathe
              </button>
              <button class="tone-button" data-tone="gentle" type="button">
                Gentle Clarity
              </button>
              <button class="tone-button" data-tone="intense" type="button">
                Luminous Fire
              </button>
            </div>
          </div>

          <!-- Questions Form -->
          <form class="questions-form" id="reflectionForm">
            <!-- Question 1: Dream -->
            <div class="question-card">
              <div class="question-number">Question 1</div>
              <h3 class="question-title">What is your dream?</h3>
              <p class="question-subtitle">
                Choose just one — the one that calls you most right now.
              </p>
              <div class="input-group">
                <textarea
                  id="dreamInput"
                  name="dream"
                  class="form-textarea"
                  placeholder="Write the dream that calls you..."
                  data-min="1"
                  data-max="3200"
                  required
                ></textarea>
                <div class="char-counter">
                  <div class="char-count" id="dreamCount">
                    0 / 3200 characters
                  </div>
                  <div class="char-progress">
                    <div class="char-progress-bar" id="dreamProgress"></div>
                  </div>
                </div>
              </div>
            </div>

            <!-- Question 2: Plan -->
            <div class="question-card">
              <div class="question-number">Question 2</div>
              <h3 class="question-title">
                What is your plan for achieving this dream?
              </h3>
              <p class="question-subtitle">
                Write what you already know. It's okay if it's unclear.
              </p>
              <div class="input-group">
                <textarea
                  id="planInput"
                  name="plan"
                  class="form-textarea"
                  placeholder="Describe any plan (or absence of plan)..."
                  data-min="1"
                  data-max="4000"
                  required
                ></textarea>
                <div class="char-counter">
                  <div class="char-count" id="planCount">
                    0 / 4000 characters
                  </div>
                  <div class="char-progress">
                    <div class="char-progress-bar" id="planProgress"></div>
                  </div>
                </div>
              </div>
            </div>

            <!-- Question 3: Date -->
            <div class="question-card">
              <div class="question-number">Question 3</div>
              <h3 class="question-title">
                Have you set a definite date for fulfilling your dream?
              </h3>
              <div class="choice-buttons">
                <button class="choice-button" type="button" data-value="yes">
                  Yes
                </button>
                <button class="choice-button" type="button" data-value="no">
                  No
                </button>
              </div>
              <input type="hidden" name="hasDate" required />
              <div class="date-container" id="dateContainer">
                <label class="date-label">What is the date?</label>
                <input type="date" class="date-input" name="dreamDate" />
              </div>
            </div>

            <!-- Question 4: Relationship -->
            <div class="question-card">
              <div class="question-number">Question 4</div>
              <h3 class="question-title">
                What is your current relationship with this dream?
              </h3>
              <p class="question-subtitle">
                Do you believe you'll achieve it? Why or why not?
              </p>
              <div class="input-group">
                <textarea
                  id="relationshipInput"
                  name="relationship"
                  class="form-textarea"
                  placeholder="How do you relate to this dream now?"
                  data-min="1"
                  data-max="4000"
                  required
                ></textarea>
                <div class="char-counter">
                  <div class="char-count" id="relationshipCount">
                    0 / 4000 characters
                  </div>
                  <div class="char-progress">
                    <div
                      class="char-progress-bar"
                      id="relationshipProgress"
                    ></div>
                  </div>
                </div>
              </div>
            </div>

            <!-- Question 5: Offering -->
            <div class="question-card">
              <div class="question-number">Question 5</div>
              <h3 class="question-title">
                What are you willing to give in return?
              </h3>
              <p class="question-subtitle">
                Energy, focus, love, time — what will you offer to this dream?
              </p>
              <div class="input-group">
                <textarea
                  id="offeringInput"
                  name="offering"
                  class="form-textarea"
                  placeholder="What will you offer in return?"
                  data-min="1"
                  data-max="2400"
                  required
                ></textarea>
                <div class="char-counter">
                  <div class="char-count" id="offeringCount">
                    0 / 2400 characters
                  </div>
                  <div class="char-progress">
                    <div class="char-progress-bar" id="offeringProgress"></div>
                  </div>
                </div>
              </div>
            </div>

            <button type="submit" class="submit-button" id="submitButton">
              Receive Your Reflection
            </button>
          </form>
        </section>

        <!-- Loading Section -->
        <section class="mirror-section is-hidden" id="loadingSection">
          <div class="loading-container">
            <div class="loading-circle"></div>
            <div class="loading-text">Reflecting your truth...</div>
          </div>
        </section>

        <!-- Results Section -->
        <section class="mirror-section is-hidden" id="resultsSection">
          <div class="results-container">
            <div class="admin-notice is-hidden" id="adminNotice">
              <span>✨ Creator mode — unlimited premium reflections</span>
            </div>
            <div class="results-backdrop">
              <div class="results-content" id="reflectionContent"></div>
            </div>
            <div class="results-actions">
              <button
                class="action-button artifact-button is-hidden"
                id="createArtifactButton"
              >
                <span>🎨</span><span>Create Artifact</span>
              </button>
              <button class="action-button" id="emailButton">
                <span>📧</span><span>Mail Reflection</span>
              </button>
              <button
                class="action-button fresh-button"
                onclick="mirrorApp.startFreshReflection()"
              >
                <span>🆕</span><span>New Reflection</span>
              </button>
              <a href="/behind-the-mirror" class="action-button creator-button">
                <span>🤲</span><span>Who created this?</span>
              </a>
              <a href="/" class="action-button">
                <span>🪞</span><span>Return to Portal</span>
              </a>
            </div>
          </div>
        </section>
      </div>
    </div>

    <script>
      /* ═══════════════ MIRROR OF TRUTH - COMPLETE REWRITE ═══════════════ */
      /* Revolutionary JavaScript architecture with flawless functionality */

      "use strict";

      // ╭─ GLOBAL STATE MANAGER ─────────────────────────────────────────────╮
      class MirrorState {
        constructor() {
          this.currentTone = "fusion";
          this.isSubmitting = false;
          this.isRestoringForm = false;
          this.currentReflectionId = null;
          this.userData = null;
          this.authToken = null;
          this.components = {};
          this.currentUserId = null;
        }

        // Generate user-specific storage key
        getUserStateKey() {
          if (!this.currentUserId) return null;
          return `mirror_form_state_${this.currentUserId}`;
        }

        // Clear ALL form states (for security when user changes)
        clearAllFormStates() {
          try {
            // Clear all mirror-related session storage
            Object.keys(sessionStorage).forEach((key) => {
              if (key.startsWith("mirror_form_state")) {
                sessionStorage.removeItem(key);
              }
            });
            console.log("🧹 All form states cleared for security");
          } catch (error) {
            console.warn("Failed to clear form states:", error);
          }
        }

        // Set current user and clear other users' data
        setCurrentUser(userId, userData) {
          const previousUserId = this.currentUserId;
          this.currentUserId = userId;
          this.userData = userData;

          // If user changed, clear all previous states for security
          if (previousUserId && previousUserId !== userId) {
            console.log(
              "🔒 User changed - clearing all form states for security"
            );
            this.clearAllFormStates();
          }
        }

        // Save form state only for current authenticated user
        saveFormState(data) {
          if (this.isRestoringForm || !this.currentUserId) return;

          const stateKey = this.getUserStateKey();
          if (!stateKey) return;

          try {
            const stateData = {
              ...data,
              timestamp: Date.now(),
              userId: this.currentUserId, // Double-check user ID
            };

            sessionStorage.setItem(stateKey, JSON.stringify(stateData));
            console.log("💾 Form state saved for user:", this.currentUserId);
          } catch (error) {
            console.warn("Session storage failed:", error);
          }
        }

        // Load form state only for current authenticated user
        loadFormState() {
          if (!this.currentUserId) return null;

          const stateKey = this.getUserStateKey();
          if (!stateKey) return null;

          try {
            const data = sessionStorage.getItem(stateKey);
            if (!data) return null;

            const parsedData = JSON.parse(data);

            // Security check: ensure the saved state belongs to current user
            if (parsedData.userId !== this.currentUserId) {
              console.warn("🚨 Security: State user ID mismatch, clearing");
              sessionStorage.removeItem(stateKey);
              return null;
            }

            return parsedData;
          } catch (error) {
            console.warn("Session storage load failed:", error);
            return null;
          }
        }

        // Clear current user's form state
        clearCurrentUserFormState() {
          if (!this.currentUserId) return;

          const stateKey = this.getUserStateKey();
          if (!stateKey) return;

          try {
            sessionStorage.removeItem(stateKey);
            console.log("🧹 Current user form state cleared");
          } catch (error) {
            console.warn("Failed to clear current user form state:", error);
          }
        }

        // Save reflection with user association
        saveReflection(reflectionData) {
          try {
            const userSpecificKey = `reflection_${this.currentUserId}_${reflectionData.id}`;
            localStorage.setItem(
              userSpecificKey,
              JSON.stringify({
                ...reflectionData,
                userId: this.currentUserId,
              })
            );

            // Update URL immediately
            this.updateURLState(reflectionData.id);

            console.log("💾 Reflection saved with URL state updated");
          } catch (error) {
            console.warn("Reflection storage failed:", error);
          }
        }

        // URL State Management
        updateURLState(reflectionId) {
          const url = new URL(window.location);
          url.searchParams.set("state", "reflection");
          url.searchParams.set("id", reflectionId);

          // Use replaceState to update URL without adding to history
          window.history.replaceState(
            { state: "reflection", reflectionId },
            "",
            url
          );

          console.log("🔗 URL state updated:", url.toString());
        }

        // Clear URL state when starting fresh
        clearURLState() {
          const url = new URL(window.location);
          url.searchParams.delete("state");
          url.searchParams.delete("id");

          window.history.replaceState({ state: "questionnaire" }, "", url);

          console.log("🧹 URL state cleared");
        }
      }

      // ╭─ TONE BACKGROUND MANAGER ──────────────────────────────────────────╮
      class ToneManager {
        constructor() {
          this.currentElements = [];
          this.container = document.getElementById("toneElements");
        }

        setTone(tone) {
          // Clear existing elements
          this.clearElements();

          // Update body class
          document.body.className = document.body.className.replace(
            /tone-\w+/g,
            ""
          );
          document.body.classList.add(`tone-${tone}`);

          // Create new tone elements
          this.createToneElements(tone);
        }

        clearElements() {
          this.currentElements.forEach((el) => el.remove());
          this.currentElements = [];
        }

        createToneElements(tone) {
          if (tone === "fusion") {
            this.createFusionElements();
          } else if (tone === "gentle") {
            this.createGentleElements();
          } else if (tone === "intense") {
            this.createIntenseElements();
          }
        }

        createFusionElements() {
          for (let i = 0; i < 6; i++) {
            const breath = document.createElement("div");
            breath.className = "fusion-breath";
            breath.style.cssText = `
              width: ${200 + Math.random() * 140}px;
              height: ${200 + Math.random() * 140}px;
              left: ${Math.random() * 100}%;
              top: ${Math.random() * 100}%;
              animation-delay: ${i * 4.2}s;
              animation-duration: ${20 + Math.random() * 10}s;
            `;
            this.container.appendChild(breath);
            this.currentElements.push(breath);
          }
        }

        createGentleElements() {
          for (let i = 0; i < 35; i++) {
            const star = document.createElement("div");
            star.className = "gentle-star";
            star.style.cssText = `
              left: ${Math.random() * 100}%;
              top: ${Math.random() * 100}%;
              animation-delay: ${Math.random() * 10}s;
              animation-duration: ${8 + Math.random() * 6}s;
            `;
            this.container.appendChild(star);
            this.currentElements.push(star);
          }
        }

        createIntenseElements() {
          for (let i = 0; i < 7; i++) {
            const swirl = document.createElement("div");
            swirl.className = "intense-swirl";
            swirl.style.cssText = `
              left: ${Math.random() * 100}%;
              top: ${Math.random() * 100}%;
              animation-delay: ${i * 3.5}s;
              animation-duration: ${15 + Math.random() * 10}s;
            `;
            this.container.appendChild(swirl);
            this.currentElements.push(swirl);
          }
        }
      }

      // ╭─ CHARACTER COUNTER COMPONENT ──────────────────────────────────────╮
      class CharacterCounter {
        constructor(textarea, countElement, progressElement) {
          this.textarea = textarea;
          this.countElement = countElement;
          this.progressElement = progressElement;
          this.min = parseInt(textarea.dataset.min) || 0;
          this.max = parseInt(textarea.dataset.max) || 1000;

          this.init();
        }

        init() {
          this.textarea.addEventListener("input", () => this.update());
          this.update(); // Initial update
        }

        update() {
          const length = this.textarea.value.length;
          const percentage = (length / this.max) * 100;

          // Update display
          this.countElement.textContent = `${length} / ${this.max} characters`;
          this.progressElement.style.width = `${Math.min(percentage, 100)}%`;

          // Update styling
          this.countElement.classList.remove("approaching-limit", "at-limit");
          if (length >= this.max) {
            this.countElement.classList.add("at-limit");
          } else if (length >= this.max * 0.8) {
            this.countElement.classList.add("approaching-limit");
          }

          // Validation styling - just ensure field isn't empty if required
          const isValid = this.textarea.required ? length > 0 : true;
          this.textarea.style.borderColor =
            this.textarea.required && length === 0
              ? "rgba(239, 68, 68, 0.4)"
              : "";

          return { length, isValid, percentage };
        }

        getStats() {
          return {
            min: this.min,
            max: this.max,
            current: this.textarea.value.length,
          };
        }
      }

      // ╭─ MAIN APPLICATION CLASS ───────────────────────────────────────────╮
      class MirrorApplication {
        constructor() {
          this.state = new MirrorState();
          this.toneManager = new ToneManager();
          this.characterCounters = new Map();
        }

        async init() {
          console.log("🪞 Initializing Mirror of Truth...");

          try {
            await this.initializeAuthentication();
            this.setupComponents();
            this.setupEventListeners();
            this.setupSecurityCleanup();
            this.initializeTone();

            // *** CHECK AND RESTORE REFLECTION STATE FIRST ***
            await this.checkAndRestoreReflectionState();

            console.log("✨ Mirror initialization complete");
          } catch (error) {
            console.error("💥 Initialization failed:", error);
            this.handleInitializationError(error);
          }
        }

        async initializeAuthentication() {
          const urlParams = new URLSearchParams(window.location.search);
          const mode = urlParams.get("mode");
          const premium = urlParams.get("premium");

          // Clear any existing states first for security
          this.state.clearAllFormStates();

          this.state.authToken = localStorage.getItem("mirror_auth_token");

          if (mode === "creator") {
            const userData = {
              isCreator: true,
              name: "Ahiya",
              email: "ahiya.butman@gmail.com",
              tier: "premium",
              id: "creator_ahiya", // Unique user ID
            };
            this.state.setCurrentUser(userData.id, userData);
            this.showAdminNotice(
              "✨ Creator mode — unlimited premium reflections"
            );
          } else if (mode === "user") {
            const userData = {
              name: "Test User",
              email: "test@example.com",
              tier: premium === "true" ? "premium" : "essential",
              testMode: true,
              id: `test_user_${Date.now()}`, // Unique test user ID
            };
            this.state.setCurrentUser(userData.id, userData);
            this.showAdminNotice(
              `🌟 Test mode — ${
                premium === "true" ? "premium" : "essential"
              } reflection`
            );
          } else if (!this.state.authToken) {
            this.redirectToAuth("Authentication required for reflections");
            return;
          } else {
            try {
              const userData = await this.verifyAuthToken();
              this.state.setCurrentUser(userData.id, userData);
            } catch (error) {
              this.redirectToAuth(
                "Authentication failed, please sign in again"
              );
              return;
            }
          }

          console.log("🔐 Authentication complete:", {
            user: this.state.userData?.name || "Anonymous",
            tier: this.state.userData?.tier || "unknown",
            userId: this.state.currentUserId,
          });
        }

        async verifyAuthToken() {
          const response = await fetch("/api/auth", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${this.state.authToken}`,
            },
            body: JSON.stringify({ action: "verify-token" }),
          });

          const result = await response.json();
          if (!result.success || !result.user) {
            throw new Error("Token verification failed");
          }

          return result.user;
        }

        redirectToAuth(message) {
          alert(message);
          const returnUrl = encodeURIComponent(
            window.location.pathname + window.location.search
          );
          window.location.href = `/auth/signin?returnTo=${returnUrl}`;
        }

        showAdminNotice(message) {
          const notice = document.getElementById("adminNotice");
          notice.classList.remove("is-hidden");
          notice.innerHTML = `<span>${message}</span>`;
        }

        // New method to check URL state and restore reflection if needed
        async checkAndRestoreReflectionState() {
          const urlParams = new URLSearchParams(window.location.search);
          const urlState = urlParams.get("state");
          const reflectionId = urlParams.get("id");

          console.log("🔍 Checking URL state:", { urlState, reflectionId });

          if (urlState === "reflection" && reflectionId) {
            console.log("🔄 Attempting to restore reflection from URL...");

            // Try to load reflection from localStorage first
            const storedReflection = this.loadStoredReflection(reflectionId);

            if (storedReflection) {
              console.log("✅ Found stored reflection, displaying...");
              this.displayStoredReflection(storedReflection);
              return;
            }

            // If not in localStorage, try to fetch from server
            console.log(
              "🌐 Reflection not found locally, fetching from server..."
            );
            try {
              await this.fetchAndDisplayReflection(reflectionId);
              return;
            } catch (error) {
              console.error("💥 Failed to fetch reflection:", error);
              // Fall through to show questionnaire
            }
          }

          // If no reflection to restore, proceed with normal form restoration
          this.restoreFormState();
        }

        // Load reflection from localStorage with user validation
        loadStoredReflection(reflectionId) {
          try {
            // Try user-specific key first
            const userSpecificKey = `reflection_${this.state.currentUserId}_${reflectionId}`;
            let stored = localStorage.getItem(userSpecificKey);

            // Fallback to legacy key format
            if (!stored) {
              stored = localStorage.getItem(`reflection_${reflectionId}`);
            }

            if (!stored) return null;

            const reflection = JSON.parse(stored);

            // Security check: ensure reflection belongs to current user
            if (
              reflection.userId &&
              reflection.userId !== this.state.currentUserId
            ) {
              console.warn("🚨 Security: Reflection user mismatch");
              return null;
            }

            return reflection;
          } catch (error) {
            console.error("💥 Error loading stored reflection:", error);
            return null;
          }
        }

        // Display a stored reflection
        displayStoredReflection(reflection) {
          console.log("📖 Displaying stored reflection...");

          // Update state
          this.state.currentReflectionId = reflection.id;

          // Show reflection content
          document.getElementById("reflectionContent").innerHTML =
            reflection.content;

          // Show premium badge if applicable
          if (reflection.isPremium) {
            this.showPremiumBadge();
          }

          // Show artifact button if premium
          if (reflection.isPremium) {
            document
              .getElementById("createArtifactButton")
              .classList.remove("is-hidden");
          }

          // Show admin notice if creator
          if (this.state.userData?.isCreator) {
            this.showAdminNotice(
              "✨ Creator mode — unlimited premium reflections"
            );
          }

          // Transition to results section
          this.showSection("resultsSection");

          console.log("✅ Stored reflection displayed successfully");
        }

        // Fetch reflection from server
        async fetchAndDisplayReflection(reflectionId) {
          console.log("🔄 Fetching reflection from server:", reflectionId);

          const headers = { "Content-Type": "application/json" };
          if (this.state.authToken) {
            headers["Authorization"] = `Bearer ${this.state.authToken}`;
          }

          const response = await fetch(`/api/reflections/${reflectionId}`, {
            method: "GET",
            headers: headers,
          });

          if (!response.ok) {
            throw new Error(`Failed to fetch reflection: ${response.status}`);
          }

          const data = await response.json();

          if (!data.success || !data.reflection) {
            throw new Error("Invalid reflection response");
          }

          console.log("✅ Reflection fetched from server");

          // Store it locally for future use
          this.state.saveReflection({
            id: reflectionId,
            content: data.reflection.ai_response,
            isPremium: data.reflection.is_premium,
            timestamp: Date.now(),
            userData: this.state.userData,
          });

          // Display it
          this.displayStoredReflection({
            id: reflectionId,
            content: data.reflection.ai_response,
            isPremium: data.reflection.is_premium,
          });
        }

        setupComponents() {
          console.log("🔧 Setting up components...");

          // Setup character counters for all textareas
          document.querySelectorAll(".form-textarea").forEach((textarea) => {
            const countElement =
              textarea.parentElement.querySelector(".char-count");
            const progressElement =
              textarea.parentElement.querySelector(".char-progress-bar");

            if (countElement && progressElement) {
              const counter = new CharacterCounter(
                textarea,
                countElement,
                progressElement
              );
              this.characterCounters.set(textarea.id, counter);
            }
          });

          console.log("✅ Components setup complete");
        }

        setupEventListeners() {
          console.log("👂 Setting up event listeners...");

          // Tone selection
          document.querySelectorAll(".tone-button").forEach((button) => {
            button.addEventListener("click", (e) => {
              e.preventDefault();
              this.handleToneSelection(button.dataset.tone);
            });
          });

          // Choice buttons (Yes/No)
          document.querySelectorAll(".choice-button").forEach((button) => {
            button.addEventListener("click", (e) => {
              e.preventDefault();
              this.handleChoiceSelection(button);
            });
          });

          // Form submission
          document
            .getElementById("reflectionForm")
            .addEventListener("submit", (e) => {
              this.handleFormSubmission(e);
            });

          // Artifact creation
          document
            .getElementById("createArtifactButton")
            .addEventListener("click", (e) => {
              e.preventDefault();
              this.createArtifact();
            });

          // Email reflection
          document
            .getElementById("emailButton")
            .addEventListener("click", (e) => {
              e.preventDefault();
              this.emailReflection();
            });

          // Form state saving with user-specific handling
          document.querySelectorAll(".form-textarea").forEach((textarea) => {
            textarea.addEventListener(
              "input",
              this.debounce(() => {
                this.saveFormState();
              }, 1000)
            );
          });

          // Focus effects
          document.querySelectorAll(".form-textarea").forEach((textarea) => {
            textarea.addEventListener("focus", () => {
              this.createFocusEffect(textarea);
            });
          });

          // Date input specific handling
          document.querySelectorAll(".date-input").forEach((dateInput) => {
            dateInput.addEventListener("click", (e) => {
              console.log("Date input clicked"); // Debug log
              e.stopPropagation();
              dateInput.focus();
            });

            dateInput.addEventListener("focus", () => {
              console.log("Date input focused"); // Debug log
            });

            dateInput.addEventListener("change", () => {
              console.log("Date changed to:", dateInput.value); // Debug log
              this.saveFormState();
            });
          });

          console.log("✅ Event listeners setup complete");
        }

        setupSecurityCleanup() {
          // Clear sensitive data when page is about to unload
          window.addEventListener("beforeunload", () => {
            console.log("🔒 Page unloading - clearing sensitive form data");
            this.state.clearCurrentUserFormState();
          });

          // Clear sensitive data when tab/window loses focus (user might be switching accounts)
          document.addEventListener("visibilitychange", () => {
            if (document.hidden) {
              console.log("🔒 Tab hidden - clearing form state for security");
              this.state.clearCurrentUserFormState();
            }
          });
        }

        initializeTone() {
          this.toneManager.setTone(this.state.currentTone);
        }

        handleToneSelection(tone) {
          // Update visual selection
          document.querySelectorAll(".tone-button").forEach((btn) => {
            btn.classList.remove("is-selected");
          });
          document
            .querySelector(`[data-tone="${tone}"]`)
            .classList.add("is-selected");

          // Update state and background
          this.state.currentTone = tone;
          this.toneManager.setTone(tone);

          // Save form state
          this.saveFormState();
        }

        handleChoiceSelection(selectedButton) {
          const container = selectedButton.parentElement;
          const hiddenInput = container.parentElement.querySelector(
            'input[type="hidden"]'
          );
          const dateContainer =
            container.parentElement.querySelector(".date-container");
          const dateInput = dateContainer.querySelector("input");

          // Update button selection
          container.querySelectorAll(".choice-button").forEach((btn) => {
            btn.classList.remove("is-selected");
          });
          selectedButton.classList.add("is-selected");

          // Update hidden input
          const value = selectedButton.dataset.value;
          hiddenInput.value = value;

          console.log("Choice selected:", value); // Debug log

          // Handle date container visibility
          if (value === "yes") {
            console.log("Showing date container"); // Debug log
            dateContainer.classList.add("is-visible");
            dateInput.required = true;

            // Ensure the input is focusable and clickable
            setTimeout(() => {
              dateInput.style.pointerEvents = "auto";
              dateInput.style.position = "relative";
              dateInput.style.zIndex = "30";
              console.log("Date input should be clickable now"); // Debug log
            }, 100);
          } else {
            console.log("Hiding date container"); // Debug log
            dateContainer.classList.remove("is-visible");
            dateInput.required = false;
            dateInput.value = "";
          }

          // Save form state
          this.saveFormState();
        }

        async handleFormSubmission(e) {
          e.preventDefault();

          if (this.state.isSubmitting) {
            console.log("⚠️ Form submission already in progress");
            return;
          }

          console.log("📝 Processing form submission...");

          // Validate all required fields have content
          let isValid = true;
          for (const [textareaId, counter] of this.characterCounters) {
            const textarea = document.getElementById(textareaId);
            if (textarea.value.trim().length === 0) {
              isValid = false;
              break;
            }
          }

          if (!isValid) {
            alert(
              "Please fill in all required fields with your authentic response."
            );
            return;
          }

          // Prepare submission
          this.state.isSubmitting = true;
          const submitButton = document.getElementById("submitButton");
          submitButton.disabled = true;
          submitButton.textContent = "Creating your reflection...";

          this.showSection("loadingSection");

          try {
            // Prepare payload
            const formData = new FormData(e.target);
            const payload = {
              dream: formData.get("dream"),
              plan: formData.get("plan"),
              hasDate: formData.get("hasDate"),
              dreamDate: formData.get("dreamDate"),
              relationship: formData.get("relationship"),
              offering: formData.get("offering"),
              userName: this.state.userData?.name || "Friend",
              userEmail: this.state.userData?.email || "",
              language: "en",
              isAdmin:
                this.state.userData?.isCreator || this.state.userData?.testMode,
              isCreator: this.state.userData?.isCreator,
              isPremium:
                this.state.userData?.tier === "premium" ||
                this.state.userData?.isCreator,
              tone: this.state.currentTone,
            };

            // Submit to API
            const headers = { "Content-Type": "application/json" };
            if (this.state.authToken) {
              headers["Authorization"] = `Bearer ${this.state.authToken}`;
            }

            console.log("🔄 Sending reflection request...");
            const response = await fetch("/api/reflection", {
              method: "POST",
              headers: headers,
              body: JSON.stringify(payload),
            });

            const data = await response.json();

            // *** FIX: Handle limit exceeded specifically ***
            if (response.status === 403 && data.needsUpgrade) {
              console.log("🚫 Reflection limit reached");
              this.showLimitExceededScreen(data);
              return;
            }

            if (!data.success) {
              throw new Error(data.error || "Reflection failed");
            }

            console.log("✨ Reflection created successfully!");

            // *** IMMEDIATELY CLEAR FORM STATE FOR SECURITY ***
            this.state.clearCurrentUserFormState();
            console.log(
              "🔒 Form state cleared for security after successful submission"
            );

            // Display results
            document.getElementById("reflectionContent").innerHTML =
              data.reflection;
            this.state.currentReflectionId = data.reflectionId;

            if (data.isPremium) {
              this.showPremiumBadge();
            }

            // Show artifact button
            document
              .getElementById("createArtifactButton")
              .classList.remove("is-hidden");

            // Save reflection
            this.state.saveReflection({
              id: data.reflectionId,
              content: data.reflection,
              isPremium: data.isPremium,
              timestamp: Date.now(),
              userData: this.state.userData,
            });

            this.showSection("resultsSection");

            // Show feedback after delay
            setTimeout(() => this.showFeedbackSection(), 3000);
          } catch (error) {
            console.error("💥 Reflection creation failed:", error);
            // Don't clear form state on error so user doesn't lose their input
            document.getElementById("reflectionContent").innerHTML = `
              <h2>A moment of silence…</h2>
              <p>Your reflection is being prepared. Please try again soon.</p>
            `;
            this.showSection("resultsSection");
          } finally {
            this.state.isSubmitting = false;
            submitButton.disabled = false;
            submitButton.textContent = "Receive Your Reflection";
          }
        }

        // New method to show limit exceeded screen
        showLimitExceededScreen(limitData) {
          console.log("🚫 Showing limit exceeded screen:", limitData);

          const limitHtml = `
            <div class="limit-container">
              <div class="limit-content">
                <div class="limit-icon">🌙</div>
                <h2 class="limit-title">Reflection Limit Reached</h2>
                <p class="limit-message">${limitData.message.replace(
                  "this month",
                  "until your limit resets"
                )}</p>
                
                <div class="limit-stats">
                  <div class="stat-item">
                    <span class="stat-label">Current Usage</span>
                    <span class="stat-value">${limitData.currentUsage} / ${
            limitData.limit
          }</span>
                  </div>
                  <div class="stat-item">
                    <span class="stat-label">Current Tier</span>
                    <span class="stat-value">${limitData.tier}</span>
                  </div>
                </div>

                <div class="limit-actions">
                  <a href="/pricing" class="upgrade-button">
                    <span>✨</span>
                    <span>Upgrade to Continue</span>
                  </a>
                  <button class="back-button" onclick="mirrorApp.returnToQuestionnaire()">
                    <span>←</span>
                    <span>Back to Reflection</span>
                  </button>
                </div>

                <div class="limit-help">
                  <p>Your current reflection will be saved. You can complete it after upgrading or when your limit resets.</p>
                </div>
              </div>
            </div>
          `;

          // Create and show limit section
          const limitSection = document.createElement("section");
          limitSection.className = "mirror-section limit-section";
          limitSection.id = "limitSection";
          limitSection.innerHTML = limitHtml;

          // Add to DOM
          const contentWrapper = document.querySelector(".content-wrapper");
          contentWrapper.appendChild(limitSection);

          // Show the limit section
          this.showSection("limitSection");

          // Reset submission state
          this.state.isSubmitting = false;
          const submitButton = document.getElementById("submitButton");
          submitButton.disabled = false;
          submitButton.textContent = "Receive Your Reflection";
        }

        // Method to return to questionnaire from limit screen
        returnToQuestionnaire() {
          // Remove limit section if it exists
          const limitSection = document.getElementById("limitSection");
          if (limitSection) {
            limitSection.remove();
          }

          // Show questionnaire
          this.showSection("questionsSection");
        }

        async createArtifact() {
          if (!this.state.currentReflectionId) {
            alert("No reflection found to create artifact from.");
            return;
          }

          console.log("🎨 Creating artifact...");

          const button = document.getElementById("createArtifactButton");
          const originalContent = button.innerHTML;

          button.innerHTML = "<span>🎨</span><span>Creating...</span>";
          button.disabled = true;

          try {
            const headers = { "Content-Type": "application/json" };
            if (this.state.authToken) {
              headers["Authorization"] = `Bearer ${this.state.authToken}`;
            }

            const response = await fetch("/api/artifact", {
              method: "POST",
              headers: headers,
              body: JSON.stringify({
                reflectionId: this.state.currentReflectionId,
              }),
            });

            const data = await response.json();

            if (data.success) {
              console.log("✨ Artifact created successfully!");
              button.innerHTML =
                "<span>✅</span><span>Artifact Created!</span>";

              // Create download link
              const link = document.createElement("a");
              link.href = data.artifact.image_url;
              link.download = `reflection-artifact-${Date.now()}.png`;
              link.target = "_blank";
              link.className = "action-button";
              link.innerHTML = "<span>⬇️</span><span>Download Artifact</span>";
              link.style.marginTop = "1rem";

              button.parentNode.appendChild(link);

              setTimeout(() => link.click(), 1000);
            } else {
              throw new Error(data.error || "Artifact creation failed");
            }
          } catch (error) {
            console.error("💥 Artifact creation failed:", error);
            button.innerHTML = "<span>⚡</span><span>Try Again</span>";
            alert("Failed to create artifact. Please try again.");
          } finally {
            setTimeout(() => {
              button.innerHTML = originalContent;
              button.disabled = false;
            }, 3000);
          }
        }

        async emailReflection() {
          const button = document.getElementById("emailButton");
          const originalContent = button.innerHTML;

          button.innerHTML = "<span>📧</span><span>Sending...</span>";
          button.disabled = true;

          try {
            const response = await fetch("/api/communication", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                action: "send-reflection",
                email: this.state.userData.email,
                content: document.getElementById("reflectionContent").innerHTML,
                userName: this.state.userData.name || "Friend",
                language: "en",
                isPremium:
                  this.state.userData.tier === "premium" ||
                  this.state.userData.isCreator,
              }),
            });

            const data = await response.json();

            if (data.success) {
              button.innerHTML = "<span>✅</span><span>Sent!</span>";
            } else {
              throw new Error(data.error || "Email failed");
            }
          } catch (error) {
            console.error("💥 Email failed:", error);
            button.innerHTML = "<span>⚡</span><span>Try Again</span>";
          } finally {
            setTimeout(() => {
              button.innerHTML = originalContent;
              button.disabled = false;
            }, 3000);
          }
        }

        saveFormState() {
          if (this.state.isRestoringForm) return;

          const form = document.getElementById("reflectionForm");
          const formData = new FormData(form);

          const state = {
            dream: formData.get("dream") || "",
            plan: formData.get("plan") || "",
            hasDate: formData.get("hasDate") || "",
            dreamDate: formData.get("dreamDate") || "",
            relationship: formData.get("relationship") || "",
            offering: formData.get("offering") || "",
            tone: this.state.currentTone,
            timestamp: Date.now(),
          };

          this.state.saveFormState(state);
        }

        restoreFormState() {
          const savedState = this.state.loadFormState();
          if (!savedState || !this.shouldRestoreState(savedState)) {
            console.log("🧹 Not restoring form state - starting fresh");
            return;
          }

          console.log("🔄 Restoring form state...");

          this.state.isRestoringForm = true;

          // Restore tone
          if (savedState.tone) {
            this.handleToneSelection(savedState.tone);
          }

          // Restore form fields
          Object.entries(savedState).forEach(([key, value]) => {
            if (key === "tone" || key === "timestamp" || key === "userId")
              return;

            const field = document.querySelector(`[name="${key}"]`);
            if (field) {
              field.value = value;

              // Handle choice buttons
              if (key === "hasDate" && value) {
                const choiceButton = document.querySelector(
                  `[data-value="${value}"]`
                );
                if (choiceButton) {
                  this.handleChoiceSelection(choiceButton);
                }
              }
            }
          });

          // Update character counters
          this.characterCounters.forEach((counter) => counter.update());

          this.state.isRestoringForm = false;
          console.log("✅ Form state restored securely");
        }

        shouldRestoreState(savedState) {
          const now = Date.now();
          const stateAge = now - savedState.timestamp;
          const maxAge = 2 * 60 * 60 * 1000; // 2 hours for security

          // Security check: ensure state belongs to current user
          if (savedState.userId !== this.state.currentUserId) {
            console.log("🚨 Security: State user ID mismatch");
            return false;
          }

          // Don't restore if state is too old
          if (stateAge > maxAge) {
            console.log("🕒 Form state too old, discarding");
            return false;
          }

          // Check URL parameters for fresh start indicators
          const urlParams = new URLSearchParams(window.location.search);
          if (
            urlParams.get("fresh") === "true" ||
            urlParams.get("new") === "true"
          ) {
            console.log("🆕 Fresh start requested via URL");
            return false;
          }

          return true;
        }

        showSection(sectionId) {
          console.log(`🔄 Transitioning to section: ${sectionId}`);

          // Hide all sections
          document.querySelectorAll(".mirror-section").forEach((section) => {
            section.classList.remove("is-visible");
            section.classList.add("is-hidden");
          });

          // Show target section
          const targetSection = document.getElementById(sectionId);
          setTimeout(() => {
            targetSection.classList.remove("is-hidden");
            targetSection.classList.add("is-visible");
          }, 300);
        }

        showPremiumBadge() {
          const backdrop = document.querySelector(".results-backdrop");
          const badge = document.createElement("div");
          badge.className = "premium-badge";
          badge.innerHTML = "✨ Premium Reflection";
          backdrop.insertBefore(badge, backdrop.firstChild);
        }

        createFocusEffect(textarea) {
          const rect = textarea.getBoundingClientRect();
          const effect = document.createElement("div");

          if (this.state.currentTone === "fusion") {
            effect.style.cssText = `
              position: fixed;
              left: ${rect.left + rect.width / 2}px;
              top: ${rect.top + rect.height / 2}px;
              width: 180px;
              height: 180px;
              margin-left: -90px;
              margin-top: -90px;
              border-radius: 50%;
              background: radial-gradient(circle, rgba(251, 191, 36, 0.2) 0%, rgba(245, 158, 11, 0.1) 40%, transparent 70%);
              pointer-events: none;
              z-index: 5;
              animation: subtleExpand 3.5s ease-out forwards;
            `;
          } else if (this.state.currentTone === "gentle") {
            for (let i = 0; i < 6; i++) {
              setTimeout(() => {
                const star = document.createElement("div");
                const offsetX = (Math.random() - 0.5) * 200;
                const offsetY = (Math.random() - 0.5) * 200;
                star.style.cssText = `
                  position: fixed;
                  left: ${rect.left + rect.width / 2 + offsetX}px;
                  top: ${rect.top + rect.height / 2 + offsetY}px;
                  width: 4px;
                  height: 4px;
                  background: rgba(255, 255, 255, 0.9);
                  border-radius: 50%;
                  box-shadow: 0 0 8px rgba(255, 255, 255, 0.6);
                  pointer-events: none;
                  z-index: 5;
                  animation: subtleTwinkle 2.5s ease-out forwards;
                `;
                document.body.appendChild(star);
                setTimeout(() => star.remove(), 2500);
              }, i * 200);
            }
            return; // Don't create the main effect element for gentle
          } else if (this.state.currentTone === "intense") {
            effect.style.cssText = `
              position: fixed;
              left: ${rect.left + rect.width / 2}px;
              top: ${rect.top + rect.height / 2}px;
              width: 150px;
              height: 150px;
              margin-left: -75px;
              margin-top: -75px;
              border-radius: 50%;
              background: radial-gradient(circle, rgba(147, 51, 234, 0.25) 0%, rgba(168, 85, 247, 0.12) 40%, transparent 70%);
              pointer-events: none;
              z-index: 5;
              animation: subtileSwirl 3.5s ease-out forwards;
            `;
          }

          if (this.state.currentTone !== "gentle") {
            document.body.appendChild(effect);
            setTimeout(() => effect.remove(), 3500);
          }
        }

        showFeedbackSection() {
          if (document.getElementById("feedbackSection")) return;

          console.log("💭 Showing feedback section...");

          const feedbackHtml = `
            <div class="feedback-section" id="feedbackSection">
              <div class="feedback-content">
                <h3 class="feedback-title">How deeply did this help you access your truth?</h3>
                <div class="rating-container">
                  ${[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
                    .map(
                      (n) =>
                        `<button class="rating-button" data-rating="${n}" type="button">${n}</button>`
                    )
                    .join("")}
                </div>
                <div class="rating-labels">
                  <span>Not at all</span>
                  <span>Deeply</span>
                </div>
                <textarea 
                  class="feedback-textarea" 
                  id="feedbackTextarea"
                  placeholder="What emerged for you? (optional)"
                  maxlength="500"
                  rows="3"
                ></textarea>
                <div class="feedback-buttons">
                  <button class="feedback-submit" id="feedbackSubmit" type="button">Submit & Continue</button>
                  <button class="feedback-skip" id="feedbackSkip" type="button">Skip</button>
                </div>
              </div>
            </div>
          `;

          const actionsSection = document.querySelector(".results-actions");
          actionsSection.insertAdjacentHTML("beforebegin", feedbackHtml);

          this.setupFeedbackInteractions();
        }

        setupFeedbackInteractions() {
          let selectedRating = null;

          // Rating buttons
          document.querySelectorAll(".rating-button").forEach((button) => {
            button.addEventListener("click", () => {
              document.querySelectorAll(".rating-button").forEach((btn) => {
                btn.classList.remove("is-selected");
              });
              button.classList.add("is-selected");
              selectedRating = parseInt(button.dataset.rating);
            });
          });

          // Submit feedback
          document
            .getElementById("feedbackSubmit")
            .addEventListener("click", async () => {
              if (!selectedRating) {
                alert("Please select a rating from 1-10");
                return;
              }

              await this.submitFeedback(selectedRating);
            });

          // Skip feedback
          document
            .getElementById("feedbackSkip")
            .addEventListener("click", () => {
              this.hideFeedbackSection();
            });
        }

        async submitFeedback(rating) {
          const feedbackText = document
            .getElementById("feedbackTextarea")
            .value.trim();

          try {
            const response = await fetch("/api/reflections", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${this.state.authToken}`,
              },
              body: JSON.stringify({
                action: "submit-feedback",
                reflectionId: this.state.currentReflectionId,
                rating: rating,
                feedback: feedbackText,
              }),
            });

            const data = await response.json();

            if (data.success) {
              console.log("✅ Feedback submitted successfully");
              const submitButton = document.getElementById("feedbackSubmit");
              submitButton.textContent = "✓ Thank you!";
              submitButton.disabled = true;
              setTimeout(() => this.hideFeedbackSection(), 1500);
            } else {
              console.error("💥 Failed to submit feedback:", data.error);
              this.hideFeedbackSection();
            }
          } catch (error) {
            console.error("💥 Feedback submission error:", error);
            this.hideFeedbackSection();
          }
        }

        hideFeedbackSection() {
          const feedbackSection = document.getElementById("feedbackSection");
          if (feedbackSection) {
            feedbackSection.style.transition = "all 0.5s ease";
            feedbackSection.style.opacity = "0";
            feedbackSection.style.transform = "translateY(-20px)";
            setTimeout(() => feedbackSection.remove(), 500);
          }
        }

        // Method to start fresh reflection
        startFreshReflection() {
          // Clear form state
          this.state.clearCurrentUserFormState();

          // Clear URL state
          this.state.clearURLState();

          // Reset to questionnaire
          this.showSection("questionsSection");

          // Clear form fields
          document.getElementById("reflectionForm").reset();

          // Reset tone to default
          this.handleToneSelection("fusion");

          // Update character counters
          this.characterCounters.forEach((counter) => counter.update());

          console.log("🆕 Fresh reflection started");
        }

        handleInitializationError(error) {
          console.error("💥 Fatal initialization error:", error);
          document.body.innerHTML = `
            <div style="
              position: fixed;
              inset: 0;
              background: #020617;
              color: white;
              display: flex;
              align-items: center;
              justify-content: center;
              flex-direction: column;
              gap: 2rem;
              text-align: center;
              padding: 2rem;
            ">
              <h1 style="font-size: 2rem; margin: 0;">Mirror Temporarily Unavailable</h1>
              <p style="margin: 0; opacity: 0.8;">The reflection portal is experiencing technical difficulties.</p>
              <button onclick="window.location.reload()" style="
                padding: 1rem 2rem;
                background: rgba(255, 255, 255, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 16px;
                color: white;
                cursor: pointer;
                font-size: 1rem;
              ">Try Again</button>
            </div>
          `;
        }

        debounce(func, wait) {
          let timeout;
          return function executedFunction(...args) {
            const later = () => {
              clearTimeout(timeout);
              func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
          };
        }
      }

      // ╭─ APPLICATION INITIALIZATION ───────────────────────────────────────╮
      let mirrorApp;

      // Initialize when DOM is ready
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", initializeApp);
      } else {
        initializeApp();
      }

      function initializeApp() {
        try {
          mirrorApp = new MirrorApplication();
          mirrorApp.init();
        } catch (error) {
          console.error("💥 Failed to initialize Mirror of Truth:", error);
        }
      }

      // Global access for debugging
      window.mirrorApp = mirrorApp;

      console.log("🪞 Mirror of Truth script loaded and ready");
    </script>
  </body>
</html>
